"For T = 'whichplanetistheredplanetaustralialawsofcanberra' return a string of all indices in T": |
"0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,"

"For T = 'whichplanetistheredplanetaustralialawsofcanberra' and P = lant, iterate over T in increments equal to the length of P, and \
collect the starting indices where P would align in T. Return these indices as a comma-separated string. In other words, imagine laying \
P repeatedly (in tandem) across T. Which positions in T correspond to Pâ€™s index 0 for each alignment?": |
"0,4,8,12,16,20,24,28,32,36,40,44,"

"Return characters of T = 'whichplanetistheredplanetaustralialawsofcanberra' at increments of length P = lant. \
That is, instead of returning the starting indices of P in T, as in the previous problem, return the characters. This \
can be done by slicing": "whnsrlttiwce"

"Use brute-force pattern matching method to return all starting indices of \
P = 'la' in T = 'whichplanetistheredplanetaustralialawsofcanberra'. That is, test P at every indices of T": "[6,20,34]"

"Compare pattern P = 'lmn' with T = 'rlnlmnolo' by beginning at the right edge of the pattern and moving left along T. \
If a match is found, return the starting index of T. Return -1 if no match": 3

"Walk backward from the end of segment 'redpantkswoplaneroofjkplantpitgopaplplanat' checking if a given \
char is in the adjust dict: {'a': 3, 'l': 2, 'o': 1}. If so, replace it with an underscore, '_', and adjust \
the pointer righward by the corresponding value in adjust."

